---
layout: post
title: "记一次JVM老生代增长过快原因排查"
description: "这篇记录了一次GC老生代对象快速增长的问题排查过程及思路"
category: GC
tags: [JVM, GC]
---

临近双11，大家都忙着发布各种优化版本，程序猿手起键落，满意的敲下最后一个回车键，心里想着这就是双十一最终版了，然而不知道等着他的是下一个双十一最终版……

版本上线后，通过几天的观察，优化目标达到了，但是，程序猿发现一个异常现象，之前一直非常平稳的JVM老生代大小突然在上线后以有了明显的增长，而且是持续的增长。于是程序猿开始了这次老生代过快增长的问题排查……

### 排查过程记录分析内存，先得找个好用的工具，淘宝开源的[TBJMap](https://github.com/jlusdy/TBJMap)对jmap做了个增强版，可以将JVM新老生代的各个对象实例个数和大小的Histgram打印出来。
看下这老生代里到底是什么对象在不断增长，用TBJMap的改版（同事做的优化版）分别dump两天的老生代对象实例出来：
第一天的dump：
```
#num	#all count/bytes    #old count/bytes   #Class description
-----------------------------------------------------------------------------------
1:	       102/    1k        102/    1k   $Proxy22
2:	      7073/  283k       6403/  258k   boolean[]
3:	    200073/  157m      85594/  135m   byte[]
4:	       493/   26k        137/    4k   byte[][]
...
60:	    365800/   22m     357186/   21m   com.mysql.jdbc.ConnectionPropertiesImpl$BooleanConnectionProperty
61:	     86800/    5m      84756/    5m   com.mysql.jdbc.ConnectionPropertiesImpl$IntegerConnectionProperty
62:	      3100/  193k       3027/  189k   com.mysql.jdbc.ConnectionPropertiesImpl$LongConnectionProperty
63:	      9300/  653k       9081/  638k   com.mysql.jdbc.ConnectionPropertiesImpl$MemorySizeConnectionProperty
64:	    127100/    7m     124107/    7m   com.mysql.jdbc.ConnectionPropertiesImpl$StringConnectionProperty
65:	      3100/    3m       3027/    3m   com.mysql.jdbc.JDBC4Connection
66:	      3126/   97k       3027/   94k   com.mysql.jdbc.JDBC4DatabaseMetaData
67:	       990/  239k        924/  223k   com.mysql.jdbc.MysqlIO
68:	      2927/   68k       2854/   66k   com.mysql.jdbc.NetworkResources
69:	      3100/   96k       3027/   94k   com.mysql.jdbc.NonRegisteringDriver$ConnectionPhantomReference
...```从这份dump中可以发现JDBC4Connection这个类有些奇怪，程序里用了连接池，但这里的连接实例个数却有3027个，远远超过连接池配置的最大连接数，带着这个疑问，再看看第二天的dump：
```#num	#all count/bytes    #old count/bytes   #Class description
-----------------------------------------------------------------------------------
1:	       102/    1k        102/    1k   $Proxy22
2:	      8407/  336k       8017/  321k   boolean[]
3:	    196962/  174m      88444/  153m   byte[]
4:	       512/   27k        190/    5k   byte[][]
...
60:	    462088/   28m     452412/   27m   com.mysql.jdbc.ConnectionPropertiesImpl$BooleanConnectionProperty
61:	    109648/    6m     107352/    6m   com.mysql.jdbc.ConnectionPropertiesImpl$IntegerConnectionProperty
62:	      3916/  244k       3834/  239k   com.mysql.jdbc.ConnectionPropertiesImpl$LongConnectionProperty
63:	     11748/  826k      11502/  808k   com.mysql.jdbc.ConnectionPropertiesImpl$MemorySizeConnectionProperty
64:	    160556/    9m     157194/    9m   com.mysql.jdbc.ConnectionPropertiesImpl$StringConnectionProperty
65:	      3916/    4m       3834/    4m   com.mysql.jdbc.JDBC4Connection
66:	      3933/  122k       3834/  119k   com.mysql.jdbc.JDBC4DatabaseMetaData
67:	      1266/  306k       1200/  290k   com.mysql.jdbc.MysqlIO
68:	      3697/   86k       3615/   84k   com.mysql.jdbc.NetworkResources
69:	      3916/  122k       3834/  119k   com.mysql.jdbc.NonRegisteringDriver$ConnectionPhantomReference
...```两份dump对比，不难发现老生代里明显增长的对象就是这个JDBC4Connection（其他几个都是和这个类相关引用的）。
到底是哪里来的这些数据库连接呢？
通过MAT对jmap heap dump文件分析，JDBC4Connection这个对象一共有3792个实例，占用了100多M内存。
![image](https://raw.githubusercontent.com/Neway6655/neway6655.github.com/master/images/jvm-old-gen-increase/JDBC4Connection.png)

再看看其中一个实例的GC Root Path：![image](https://raw.githubusercontent.com/Neway6655/neway6655.github.com/master/images/jvm-old-gen-increase/JDBC4Connection_Normal.png)

可见它被两个对象引用，一个是连接池BasicResourcePool，一个是MySQL JDBC Driver的ConnectionPhantomReference，跟踪到源码中看看：

BasicResourcePool.java

```
    /* all valid, managed resources currently available for checkout */
    LinkedList unused = new LinkedList();
```
可见unused对象是连接池里的正常可用的连接。

NonRegisteringDriver.java

```
	protected static void trackConnection(Connection newConn) {
		ConnectionPhantomReference phantomRef = new ConnectionPhantomReference((ConnectionImpl) newConn, refQueue);
		connectionPhantomRefs.put(phantomRef, phantomRef);
	}
```这个虚引用是在JDBC Driver在构造connection时用了track这个connection，在被回收前做一些clean up（释放资源）用的，所以每个connection被构造出来后，都会被track，这是Driver为了防止有资源随着连接回收而未释放的手段。
可见，这个JDBC4Connection实例是堂堂正正的连接池里的连接实例，呆在老生代是正常的。
再来看另一个：
![image](https://raw.githubusercontent.com/Neway6655/neway6655.github.com/master/images/jvm-old-gen-increase/JDBC4Connection_Abnormal.png)

这个实例除了ConnectionPhantomReference引用外，还有一个也是连接池BasicResourcePool里的对象，但不同之前，从名字上也能看出来：formerResources（曾经的连接对象），看看代码：

```
            else if ( isFormerResource(resc) )
            {
                if ( logger.isLoggable( MLevel.FINER ) )
                    logger.finer("Resource " + resc + " checked-in after having been checked-in already, or checked-in after " +
                    " having being destroyed for being checked-out too long.");
            }
```这个是用来在连接池回收连接时用来判断是否应该收回用的。
看到这里，基本已经清晰了，这些多出来的连接对象，都是曾经被连接池里创建出来，用完后被抛弃掉的连接，被放到formerResource，这些对象显然是熬过了新生代的YGC，留到了老生代，等着被老生代GC回收的退休对象。
###后续进一步排查
既然确认是formerResource引起的老生代增长，那为什么一天的时间，会产生这么多的formerResource，是什么情况会导致连接被加入formerResource呢？
To be continued...
