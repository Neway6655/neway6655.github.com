---
layout: post
title: "记一次JVM老生代增长过快原因排查"
description: "这篇记录了一次GC老生代对象快速增长的问题排查过程及思路"
category: GC
tags: [JVM, GC]
---

临近双11，大家都忙着发布各种优化版本，程序猿手起键落，满意的敲下最后一个回车键，心里想着这就是双十一最终版了，然而不知道等着他的是下一个双十一最终版……

版本上线后，通过几天的观察，优化目标达到了，但是，程序猿发现一个异常现象，之前一直非常平稳的JVM老生代大小突然在上线后以有了明显的增长，而且是持续的增长。于是程序猿开始了这次老生代过快增长的问题排查……

### 揪出导致老生代快速增长的对象分析内存对象，先得找个好用的工具，淘宝开源的[TBJMap](https://github.com/jlusdy/TBJMap)对jmap做了个增强版，可以将JVM新老生代的各个对象实例个数和大小的Histgram打印出来。
看下这老生代里到底是什么对象在不断增长，用TBJMap的改版（同事做的优化版）分别dump两天的老生代对象实例出来：
第一天的dump：
```
#num	#all count/bytes    #old count/bytes   #Class description
-----------------------------------------------------------------------------------
1:	       102/    1k        102/    1k   $Proxy22
2:	      7073/  283k       6403/  258k   boolean[]
3:	    200073/  157m      85594/  135m   byte[]
4:	       493/   26k        137/    4k   byte[][]
...
60:	    365800/   22m     357186/   21m   com.mysql.jdbc.ConnectionPropertiesImpl$BooleanConnectionProperty
61:	     86800/    5m      84756/    5m   com.mysql.jdbc.ConnectionPropertiesImpl$IntegerConnectionProperty
62:	      3100/  193k       3027/  189k   com.mysql.jdbc.ConnectionPropertiesImpl$LongConnectionProperty
63:	      9300/  653k       9081/  638k   com.mysql.jdbc.ConnectionPropertiesImpl$MemorySizeConnectionProperty
64:	    127100/    7m     124107/    7m   com.mysql.jdbc.ConnectionPropertiesImpl$StringConnectionProperty
65:	      3100/    3m       3027/    3m   com.mysql.jdbc.JDBC4Connection
66:	      3126/   97k       3027/   94k   com.mysql.jdbc.JDBC4DatabaseMetaData
67:	       990/  239k        924/  223k   com.mysql.jdbc.MysqlIO
68:	      2927/   68k       2854/   66k   com.mysql.jdbc.NetworkResources
69:	      3100/   96k       3027/   94k   com.mysql.jdbc.NonRegisteringDriver$ConnectionPhantomReference
...```从这份dump中可以发现JDBC4Connection这个类有些奇怪，程序里用了连接池，但这里的连接实例个数却有3027个，远远超过连接池配置的最大连接数，带着这个疑问，再看看第二天的dump：
```#num	#all count/bytes    #old count/bytes   #Class description
-----------------------------------------------------------------------------------
1:	       102/    1k        102/    1k   $Proxy22
2:	      8407/  336k       8017/  321k   boolean[]
3:	    196962/  174m      88444/  153m   byte[]
4:	       512/   27k        190/    5k   byte[][]
...
60:	    462088/   28m     452412/   27m   com.mysql.jdbc.ConnectionPropertiesImpl$BooleanConnectionProperty
61:	    109648/    6m     107352/    6m   com.mysql.jdbc.ConnectionPropertiesImpl$IntegerConnectionProperty
62:	      3916/  244k       3834/  239k   com.mysql.jdbc.ConnectionPropertiesImpl$LongConnectionProperty
63:	     11748/  826k      11502/  808k   com.mysql.jdbc.ConnectionPropertiesImpl$MemorySizeConnectionProperty
64:	    160556/    9m     157194/    9m   com.mysql.jdbc.ConnectionPropertiesImpl$StringConnectionProperty
65:	      3916/    4m       3834/    4m   com.mysql.jdbc.JDBC4Connection
66:	      3933/  122k       3834/  119k   com.mysql.jdbc.JDBC4DatabaseMetaData
67:	      1266/  306k       1200/  290k   com.mysql.jdbc.MysqlIO
68:	      3697/   86k       3615/   84k   com.mysql.jdbc.NetworkResources
69:	      3916/  122k       3834/  119k   com.mysql.jdbc.NonRegisteringDriver$ConnectionPhantomReference
...```两份dump对比，不难发现老生代里明显增长的对象就是这个JDBC4Connection（其他几个都是和这个类相关引用的）。
到底是哪里来的这些数据库连接呢？
通过MAT对jmap heap dump文件分析，JDBC4Connection这个对象一共有3792个实例，占用了100多M内存。
![image](https://raw.githubusercontent.com/Neway6655/neway6655.github.com/master/images/jvm-old-gen-increase/JDBC4Connection.png)

再看看其中一个实例的GC Root Path：![image](https://raw.githubusercontent.com/Neway6655/neway6655.github.com/master/images/jvm-old-gen-increase/JDBC4Connection_Normal.png)

注：这里采用连接池是c3p0.

可见它被两个对象引用，一个是连接池BasicResourcePool，一个是MySQL JDBC Driver的ConnectionPhantomReference，跟踪到源码中看看：

BasicResourcePool.java

```
    /* all valid, managed resources currently available for checkout */
    LinkedList unused = new LinkedList();
```
可见unused对象是连接池里的正常可用的连接。

NonRegisteringDriver.java

```
	protected static void trackConnection(Connection newConn) {
		ConnectionPhantomReference phantomRef = new ConnectionPhantomReference((ConnectionImpl) newConn, refQueue);
		connectionPhantomRefs.put(phantomRef, phantomRef);
	}
```这个虚引用是在JDBC Driver在构造connection时用了track这个connection，在被回收前做一些clean up（释放资源）用的，所以每个connection被构造出来后，都会被track，这是Driver为了防止有资源随着连接回收而未释放的手段。
可见，这个JDBC4Connection实例是堂堂正正的连接池里的连接实例，呆在老生代是正常的。
再来看另一个：
![image](https://raw.githubusercontent.com/Neway6655/neway6655.github.com/master/images/jvm-old-gen-increase/JDBC4Connection_Abnormal.png)

这个实例除了ConnectionPhantomReference引用外，还有一个也是连接池BasicResourcePool里的对象，但不同之前，从名字上也能看出来：formerResources（曾经的连接对象），看看代码：

```
...
    else if ( isFormerResource(resc) )
    {
    	if ( logger.isLoggable( MLevel.FINER ) )
        	logger.finer("Resource " + resc + " checked-in after having been checked-in already, or checked-in after " +
            " having being destroyed for being checked-out too long.");
    }
...
```这个是用来在连接池回收连接时用来判断是否应该收回用的。
看到这里，基本已经清晰了，这些多出来的连接对象，都是曾经被连接池里创建出来，用完后被抛弃掉的连接，被放到formerResource，这些对象显然是熬过了新生代的YGC，留到了老生代，等着被老生代GC回收的退休对象。
### 这些对象怎么产生的
继续跟进生成formerResource的代码:
```
private void removeResource(Object resc, boolean synchronous){
...
	unused.remove(resc);
    destroyResource(resc, synchronous, checked_out);
    
    addToFormerResources( resc );
    
    asyncFireResourceRemoved( resc, false, managed.size(), unused.size(), excluded.size() );
...
}

private void cullExpired(){
...
	if ( shouldExpire( resc ) )
    {
    	if ( logger.isLoggable( MLevel.FINER ) )
            logger.log( MLevel.FINER, "Removing expired resource: " + resc + " [" + this + "]");

        target_pool_size = Math.max( min, target_pool_size - 1 ); //expiring a resource resources the target size to match

        removeResource( resc );

	}
...

}

public Object checkoutResource( long timeout ){
	Object resc = prelimCheckoutResource( timeout );
...
}

private synchronized Object prelimCheckoutResource( long timeout ){
...
	Object  resc = unused.get(0);
...
	else if ( shouldExpire( resc ) ){
    	removeResource( resc );
        ensureMinResources();
        return prelimCheckoutResource( timeout );
    }
...
}
```
连接在被close时，会加入formerResource，但连接close不是重点考虑的方向，close的原因比较多是因为连接异常了，需要close，否则正常连接是被池化的。

这里重点关注的是```removeResource```这个方法，这个是连接池管理连接的一个重要方法，大致浏览了下调用```removeResource```的地方，注意到```cullExpired```和```checkoutResource```这两个方法.

* ```cullExpired```这个方法是c3p0里的一个定时器执行的方法，用来定期检查过期连接的，如果配置的相关的连接池参数（max_resource_age，max_idle_time，excess_max_idle_time，destroy_unreturned_resc_time），就会对过期连接进行清理；

	再结合应用的配置，maxIdleTime设置了1800秒，结合代码逻辑，**c3p0默认会1800/4=450秒一次定时对idle连接进行`连接池过期检查`，若连接过期（空闲了1800秒），则会被remove**，也就是前面看到的，会被加入到formerResource中，如果最后剩下的idle连接超过或小于minIdle的连接数，也会相应的进行缩减（shrink）或者扩充（explode）连接池的连接，达到minIdle个连接。

	有同学可能会问：“如果设置了minIdle和idleConnectionTestPeriod，这里的连接是否也可能被清理？”

	回答是：“是的，idleConnectionTest是维持连接池的idle连接和MySQL之间的心跳，防止MySQL server端踢掉应用的连接”，而前面提到的`连接池过期检查`则是**c3p0对连接归还后是否长时间没被再次借出来判断是否过期**。”

* ```checkoutResource```则是从连接池中获取连接的方法，可以看到**每次获取连接时，都会对该连接进行过期检查的校验**，同样还是上面那些参数，比如配置了maxIdleTime是1800秒，检查时若发现连接上次借出归还后超过1800s没有再次被借出，则认为连接已过期，触发```removeResource```，将连接加入到formerResource中。

最后，结合应用调用MySQL的场景，数据先从缓存（Redis）中获取，若发生异常，则回源MySQL，优化版的改动增加了回源MySQL的概率。所以，**若是已经过期的连接，之前是定时450秒做一次检查，也就是可能会等450秒才被remove，然后再次生产新的连接；结果现在，可能没到450秒，而是通过checkout连接的同时就被remove了，加快了过期连接的失效和创建新连接的速度**，导致formerResource里的"废弃"连接变多，最终加快了老生代的增长。